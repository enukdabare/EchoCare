def max_signal_coverage(grid):
    N = len(grid)
    M = len(grid[0])
    
    left = [[0]*M for _ in range(N)]
    right = [[0]*M for _ in range(N)]
    up = [[0]*M for _ in range(N)]
    down = [[0]*M for _ in range(N)]
    
    # Process rows: left & right
    for i in range(N):
        # Left direction
        for j in range(1, M):
            if grid[i][j-1] <= grid[i][j]:
                left[i][j] = left[i][j-1] + 1
            else:
                left[i][j] = 0
        
        # Right direction
        for j in range(M-2, -1, -1):
            if grid[i][j+1] <= grid[i][j]:
                right[i][j] = right[i][j+1] + 1
            else:
                right[i][j] = 0
    
    # Process cols: up & down
    for j in range(M):
        # Up direction
        for i in range(1, N):
            if grid[i-1][j] <= grid[i][j]:
                up[i][j] = up[i-1][j] + 1
            else:
                up[i][j] = 0
        
        # Down direction
        for i in range(N-2, -1, -1):
            if grid[i+1][j] <= grid[i][j]:
                down[i][j] = down[i+1][j] + 1
            else:
                down[i][j] = 0
    
    # Compute max coverage
    max_cover = 0
    for i in range(N):
        for j in range(M):
            cover = left[i][j] + right[i][j] + up[i][j] + down[i][j] + 1
            max_cover = max(max_cover, cover)
    
    return max_cover


# ---- Driver ----
if __name__ == "__main__":
    N, M = map(int, input().split())
    grid = [list(map(int, input().split())) for _ in range(N)]
    print(max_signal_coverage(grid))





