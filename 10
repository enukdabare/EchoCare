The National Emergency Communication Authority is building a secure fiber optic network to connect two major cities, City S and City T. The network consists of N junction points (including S and T) connected by M underground bidirectional cables.

Each cable has a bandwidth capacity (in Gbps), represented by a positive integer weight. For reliability, the authority requires K independent communication routes between the two cities.

These routes must be vertex disjoint (they cannot share any intermediate junctions) to ensure that if one path fails, the others remain operational.

We want to minimize the maximum cable capacity used across all selected paths. In other words, find the smallest integer X such that there exist K vertex disjoint paths from S to T, and every cable on these paths has a capacity ≤ X.

If it is impossible to establish K such vertex disjoint paths, print -1.

Input Format

    The first line contains three integers N, M, K - the number of junction points, cables, and required disjoint paths.
    The second line contains two integers S, T - the starting city and target city.
    The next M lines each contain three integers u, v, w - a cable between junctions u and v with capacity w.

Constraints

1 ≤ N ≤ 10^5 1 ≤ M ≤ 2×10^5 1 ≤ K ≤ N 1 ≤ w ≤ 10^9 1 ≤ S, T ≤ N

    The graph is connected.
    No self-loops. Multiple edges allowed.
    Junctions are numbered 1 to N.

Output Format

    Print the minimum bottleneck capacity X.
    If it’s impossible to create K vertex-disjoint paths, print -1.

Sample Input 0
4 4 2
1 4
1 2 1
2 3 1
3 4 1
1 3 3

Sample Output 0
1

give me the python code for above question, there are 4 hidden test cases apart from mentioned inputs so make the best



import sys
from collections import deque

input = sys.stdin.readline

class Dinic:
    def __init__(self, N):
        self.N = N
        self.graph = [[] for _ in range(N)]
    
    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.graph[fr].append(forward)
        self.graph[to].append(backward)
    
    def bfs(self, s, t, level):
        q = deque([s])
        level[s] = 0
        while q:
            v = q.popleft()
            for to, cap, rev in self.graph[v]:
                if cap > 0 and level[to] < 0:
                    level[to] = level[v] + 1
                    q.append(to)
        return level[t] >= 0
    
    def dfs(self, v, t, f, level, it):
        if v == t: 
            return f
        for i in range(it[v], len(self.graph[v])):
            it[v] = i
            to, cap, rev = self.graph[v][i]
            if cap > 0 and level[v] < level[to]:
                d = self.dfs(to, t, min(f, cap), level, it)
                if d > 0:
                    self.graph[v][i][1] -= d
                    rev[1] += d
                    return d
        return 0
    
    def max_flow(self, s, t):
        flow = 0
        level = [-1] * self.N
        INF = 10**18
        while self.bfs(s, t, level):
            it = [0] * self.N
            while True:
                f = self.dfs(s, t, INF, level, it)
                if f == 0:
                    break
                flow += f
            level = [-1] * self.N
        return flow

def can_do(X):
    # build flow graph with vertex split
    node_id = {}
    cnt = 0
    for i in range(1, N+1):
        if i == S or i == T:
            node_id[(i, 'in')] = cnt
            node_id[(i, 'out')] = cnt
            cnt += 1
        else:
            node_id[(i, 'in')] = cnt
            cnt += 1
            node_id[(i, 'out')] = cnt
            cnt += 1

    dinic = Dinic(cnt)

    for u in range(1, N+1):
        if u != S and u != T:
            dinic.add_edge(node_id[(u, 'in')], node_id[(u, 'out')], 1)
    
    for u, v, w in edges:
        if w <= X:
            u_out = node_id[(u, 'out')] if u != S and u != T else node_id[(u, 'in')]
            v_in = node_id[(v, 'in')] if v != S and v != T else node_id[(v, 'in')]
            dinic.add_edge(u_out, v_in, 1)
            v_out = node_id[(v, 'out')] if v != S and v != T else node_id[(v, 'in')]
            u_in = node_id[(u, 'in')] if u != S and u != T else node_id[(u, 'in')]
            dinic.add_edge(v_out, u_in, 1)
    
    return dinic.max_flow(node_id[(S,'in')], node_id[(T,'in')]) >= K

# Input reading
N, M, K = map(int, input().split())
S, T = map(int, input().split())
edges = [tuple(map(int, input().split())) for _ in range(M)]

# Binary search
lo, hi = 1, 10**9
answer = -1
while lo <= hi:
    mid = (lo + hi) // 2
    if can_do(mid):
        answer = mid
        hi = mid - 1
    else:
        lo = mid + 1

print(answer)



77777
import sys
from collections import deque
input = sys.stdin.readline

class Dinic:
    def __init__(self, N):
        self.N = N
        self.graph = [[] for _ in range(N)]
    
    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.graph[fr].append(forward)
        self.graph[to].append(backward)
    
    def bfs(self, s, t, level):
        q = deque([s])
        level[s] = 0
        while q:
            v = q.popleft()
            for to, cap, rev in self.graph[v]:
                if cap > 0 and level[to] < 0:
                    level[to] = level[v] + 1
                    q.append(to)
        return level[t] >= 0
    
    def dfs(self, v, t, f, level, it):
        if v == t: 
            return f
        for i in range(it[v], len(self.graph[v])):
            it[v] = i
            to, cap, rev = self.graph[v][i]
            if cap > 0 and level[v] < level[to]:
                d = self.dfs(to, t, min(f, cap), level, it)
                if d > 0:
                    self.graph[v][i][1] -= d
                    rev[1] += d
                    return d
        return 0
    
    def max_flow(self, s, t):
        flow = 0
        INF = 10**18
        level = [-1] * self.N
        while self.bfs(s, t, level):
            it = [0] * self.N
            while True:
                f = self.dfs(s, t, INF, level, it)
                if f == 0:
                    break
                flow += f
            level = [-1] * self.N
        return flow

def can_do(X):
    # Split vertices (except S and T)
    node_id = {}
    cnt = 0
    for i in range(1, N+1):
        if i == S or i == T:
            node_id[(i, 'in')] = cnt
            node_id[(i, 'out')] = cnt
            cnt += 1
        else:
            node_id[(i, 'in')] = cnt
            cnt += 1
            node_id[(i, 'out')] = cnt
            cnt += 1

    dinic = Dinic(cnt)

    # Add vertex split edges (capacity=1)
    for i in range(1, N+1):
        if i != S and i != T:
            dinic.add_edge(node_id[(i,'in')], node_id[(i,'out')], 1)
    
    # Add graph edges with capacity <= X
    for u, v, w in edges:
        if w <= X:
            u_out = node_id[(u,'out')] if u != S and u != T else node_id[(u,'in')]
            v_in = node_id[(v,'in')] if v != S and v != T else node_id[(v,'in')]
            dinic.add_edge(u_out, v_in, 1)

            v_out = node_id[(v,'out')] if v != S and v != T else node_id[(v,'in')]
            u_in = node_id[(u,'in')] if u != S and u != T else node_id[(u,'in')]
            dinic.add_edge(v_out, u_in, 1)

    return dinic.max_flow(node_id[(S,'in')], node_id[(T,'in')]) >= K

# Input
N, M, K = map(int, input().split())
S, T = map(int, input().split())
edges = [tuple(map(int, input().split())) for _ in range(M)]

# Binary search over answer
lo, hi = 1, 10**9
answer = -1

while lo <= hi:
    mid = (lo + hi) // 2
    if can_do(mid):
        answer = mid
        hi = mid - 1
    else:
        lo = mid + 1

print(answer)