def solve():
    N, M = map(int, input().split())
    edges = []
    for _ in range(M):
        u, v, s = map(int, input().split())
        edges.append((s, u-1, v-1))  # store 0-based
    
    # Sort by stability (ascending = vanish order)
    edges.sort()
    
    results = []
    
    # Step by step remove edges
    for i in range(M):
        active = edges[i+1:]  # remaining bridges after i removals
        
        # Build adjacency
        g = [[] for _ in range(N)]
        for _, u, v in active:
            g[u].append(v)
        
        # BFS/DFS from 0
        seen = [False]*N
        stack = [0]
        seen[0] = True
        while stack:
            u = stack.pop()
            for v in g[u]:
                if not seen[v]:
                    seen[v] = True
                    stack.append(v)
        
        if all(seen):
            # Minimum edges needed is N-1 (a spanning tree from 1)
            results.append(N-1)
        else:
            results.append(-1)
    
    for r in results:
        print(r)

# Example run
# Input:
# 4 5
# 1 2 2
# 2 3 3
# 1 3 5
# 3 4 4
# 2 4 6
