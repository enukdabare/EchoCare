alth eka

import sys
import heapq

def main():
    data = list(map(int, sys.stdin.buffer.read().split()))
    it = iter(data)
    N = next(it); M = next(it); K = next(it)  # K not used per sample behavior
    S = next(it) - 1; T = next(it) - 1

    adj = [[] for _ in range(N)]
    for _ in range(M):
        u = next(it) - 1
        v = next(it) - 1
        w = next(it)
        adj[u].append((v, w))
        adj[v].append((u, w))

    INF = 10**18
    # bottleneck[i] = minimal possible max-edge weight along any path S->i
    bottleneck = [INF] * N
    bottleneck[S] = 0
    pq = [(0, S)]  # (current bottleneck, node)

    while pq:
        cur_bott, u = heapq.heappop(pq)
        if cur_bott != bottleneck[u]:
            continue
        if u == T:
            break
        for v, w in adj[u]:
            nb = cur_bott if cur_bott > w else w
            if nb < bottleneck[v]:
                bottleneck[v] = nb
                heapq.heappush(pq, (nb, v))

    ans = bottleneck[T]
    print(-1 if ans == INF else ans)

#if __name__ == "__main__":
#    main()




























import sys

class DSU:
    def __init__(self, n):
        self.p = list(range(n + 1))
        self.r = [0] * (n + 1)

    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x

    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        return True

data = sys.stdin.buffer.read().split()
it = iter(data)
N = int(next(it)); M = int(next(it)); K = int(next(it))
powers = [int(next(it)) for _ in range(K)]

edges = []
for _ in range(M):
    u = int(next(it)); v = int(next(it)); w = int(next(it))
    edges.append((w, u, v))

dsu_full = DSU(N)
for w, u, v in edges:
    dsu_full.union(u, v)

has_power = {}
roots = set()
for node in range(1, N + 1):
    roots.add(dsu_full.find(node))

for r in roots:
    has_power[r] = False

for p in powers:
    has_power[dsu_full.find(p)] = True

for r in roots:
    if not has_power[r]:
        print(-1)
        sys.exit(0)

edges.sort(key=lambda x: x[0])
dsu = DSU(N)
total_cost = 0
for w, u, v in edges:
    if dsu.union(u, v):
        total_cost += w


print(total_cost)   






