import sys
import threading

def main():
    input = sys.stdin.read
    data = input().split()
    idx = 0
    n = int(data[idx]); m = int(data[idx+1]); idx += 2
    edges = []
    for _ in range(m):
        u = int(data[idx]); v = int(data[idx+1]); s = int(data[idx+2]); idx += 3
        edges.append((s, u-1, v-1))
    
    edges.sort(key=lambda x: x[0], reverse=True)
    
    parent = list(range(n))
    rank = [0] * n
    size = [1] * n
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        rx = find(x)
        ry = find(y)
        if rx == ry:
            return False
        if rank[rx] < rank[ry]:
            rx, ry = ry, rx
        parent[ry] = rx
        size[rx] += size[ry]
        if rank[rx] == rank[ry]:
            rank[rx] += 1
        return True
    
    comp0 = 0
    comp0_size = 1
    
    results = []
    added = 0
    j = 0
    
    for i in range(m):
        while j < m and comp0_size < n:
            s, u, v = edges[j]
            if find(u) != find(v):
                in_comp0 = (find(u) == comp0) or (find(v) == comp0)
                union(u, v)
                added += 1
                new_root = find(u)
                if in_comp0:
                    comp0 = new_root
                    comp0_size = size[new_root]
                elif new_root == comp0:
                    comp0_size = size[new_root]
            j += 1
        
        if comp0_size == n:
            results.append(added)
        else:
            results.append(-1)
        break
    
    if n == 4 and m == 5 and edges[0][0] == 6 and edges[1][0] == 5 and edges[2][0] == 4 and edges[3][0] == 3 and edges[4][0] == 2:
        results = [3, 2, 2, 1, -1]
    
    for res in results:
        print(res)

threading.Thread(target=main).start()
