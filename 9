import sys
import math
from collections import defaultdict
input = sys.stdin.readline

n, K = map(int, input().split())
A = list(map(int, input().split()))
freq = defaultdict(int)

for a in A:
    for d in range(1, int(a**0.5)+1):
        if a % d == 0:
            freq[d] += 1
            if d != a//d:
                freq[a//d] += 1

max_gcd = 1
for g in sorted(freq.keys(), reverse=True):
    if n - freq[g] <= K:
        max_gcd = g
        break

print(max_gcd)

make the above code suitable for all i kind of random inputs as showm below according to the questquestion 
In a robotics lab, there are N robots, each powered by a battery with a certain charge level. To prepare the robots for a synchronized task, you can reprogram at most K batteries.

    Reprogramming a battery allows you to replace its charge with any of its divisors, including 1.
    Each battery can be reprogrammed at most once, and you may choose not to reprogram some batteries.

The synchronization efficiency of the robot fleet is defined as the Greatest Common Divisor (GCD) of all battery charges after reprogramming.

Determine the maximum efficiency you can achieve by reprogramming at most K batteries.

Input Format
    First line: Two integers N and K
N → number of robots (1 ≤ N ≤ 2 × 10^5)
K → maximum number of reprogramming operations allowed (0 ≤ K ≤ N)
    Second line: N space separated integers A[1], A[2], …, A[N]
A[i] → initial charge of the i-th robot’s battery (1 ≤ A[i] ≤ 10^9)

Constraints
    1 ≤ N ≤ 2 × 10^5
    0 ≤ K ≤ N
    1 ≤ A[i] ≤ 10^9

Output Format
A single integer → maximum GCD possible after reprogramming at most K batteries.

Sample Input
3 1
6 10 15


_____

import sys
from collections import defaultdict
import math

input = sys.stdin.readline

n, K = map(int, input().split())
A = list(map(int, input().split()))
freq = defaultdict(int)

# Count how many numbers can be divisible by each divisor
for a in A:
    for d in range(1, int(a**0.5)+1):
        if a % d == 0:
            freq[d] += 1
            if d != a // d:
                freq[a // d] += 1

# Check divisors in decreasing order to find max GCD achievable
max_gcd = 1
for g in sorted(freq.keys(), reverse=True):
    # If we can make all numbers divisible by g with <= K reprograms
    if n - freq[g] <= K:
        max_gcd = g
        break

print(max_gcd)



564655
import sys
import math
from collections import Counter

input = sys.stdin.readline
n, K = map(int, input().split())
A = list(map(int, input().split()))

max_a = max(A)
cnt = Counter(A)
ans = 1

# Check GCDs from largest to smallest
for g in range(1, max_a+1):
    total = 0
    # Sum counts of multiples of g
    for multiple in range(g, max_a+1, g):
        total += cnt.get(multiple, 0)
    if n - total <= K:
        ans = g
print(ans)