def countPaths(m, n, memo):
    if n == 1 or m == 1:
        memo[m][n] = 1
        return 1


    if  memo[m][n] == 0:
         memo[m][n] = countPaths(m-1,n, memo) + \
            countPaths(m,n-1, memo)

    return  memo[m][n]


def number_of_paths(m, n):
      
    memo = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
    ans = countPaths(m, n, memo)
    return ans

if __name__ == "__main__":
    n, m = 5,2

    res = number_of_paths(m, n)
    print(res)

You are given a 2D grid of size N × M, where each cell represents the height of a building.

A tower located on a building can send signals in the four cardinal directions: up, down, left, and right.

A signal stops propagating in a direction when it encounters a building with a height strictly greater than the tower. The tower itself counts as covered.

For each cell, determine how many buildings can receive a signal from that tower. Your task is to find the maximum number of buildings that can be covered by a single tower.

Input Format
First line: two integers N and M → grid dimensions (1 ≤ N, M ≤ 1000)
Next N lines: each containing M integers → building heights (1 ≤ Height ≤ 10^9)

Constraints
1 ≤ N,M ≤ 1000
1 ≤ Height ≤ 10^9

Output Format
A single integer → maximum number of buildings covered by any single tower.

make the above code eligible to pass for any type of test case given as mentioned inputs, please give the correct code



def max_signal_coverage(grid, N, M):
    max_covered = 0
    
    # Directions: up, down, left, right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    for i in range(N):
        for j in range(M):
            height = grid[i][j]
            count = 1  # The tower itself counts
            for dx, dy in directions:
                x, y = i + dx, j + dy
                while 0 <= x < N and 0 <= y < M and grid[x][y] <= height:
                    count += 1
                    x += dx
                    y += dy
            max_covered = max(max_covered, count)
    
    return max_covered

if __name__ == "__main__":
    # Read input
    N, M = map(int, input().split())
    grid = [list(map(int, input().split())) for _ in range(N)]
    
    # Get result
    result = max_signal_coverage(grid, N, M)
    print(result)

3 3
3 1 4
2 5 6
1 2 3


def max_signal_coverage(grid, N, M):
    # Initialize coverage arrays
    up = [[0]*M for _ in range(N)]
    down = [[0]*M for _ in range(N)]
    left = [[0]*M for _ in range(N)]
    right = [[0]*M for _ in range(N)]

    # Up direction
    for j in range(M):
        for i in range(N):
            if i == 0:
                up[i][j] = 1
            else:
                if grid[i-1][j] <= grid[i][j]:
                    up[i][j] = up[i-1][j] + 1
                else:
                    up[i][j] = 1

    # Down direction
    for j in range(M):
        for i in range(N-1, -1, -1):
            if i == N-1:
                down[i][j] = 1
            else:
                if grid[i+1][j] <= grid[i][j]:
                    down[i][j] = down[i+1][j] + 1
                else:
                    down[i][j] = 1

    # Left direction
    for i in range(N):
        for j in range(M):
            if j == 0:
                left[i][j] = 1
            else:
                if grid[i][j-1] <= grid[i][j]:
                    left[i][j] = left[i][j-1] + 1
                else:
                    left[i][j] = 1

    # Right direction
    for i in range(N):
        for j in range(M-1, -1, -1):
            if j == M-1:
                right[i][j] = 1
            else:
                if grid[i][j+1] <= grid[i][j]:
                    right[i][j] = right[i][j+1] + 1
                else:
                    right[i][j] = 1

    # Calculate max coverage
    max_covered = 0
    for i in range(N):
        for j in range(M):
            # Subtract 3 because the tower itself is counted 4 times
            total = up[i][j] + down[i][j] + left[i][j] + right[i][j] - 3
            max_covered = max(max_covered, total)

    return max_covered


if __name__ == "__main__":
    N, M = map(int, input().split())
    grid = [list(map(int, input().split())) for _ in range(N)]
    print(max_signal_coverage(grid, N, M))