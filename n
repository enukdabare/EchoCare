def max_coverage(grid):
    n, m = len(grid), len(grid[0])

    # Precompute left and right visibility for each row
    left = [[0]*m for _ in range(n)]
    right = [[0]*m for _ in range(n)]
    up = [[0]*m for _ in range(n)]
    down = [[0]*m for _ in range(n)]

    # LEFT
    for i in range(n):
        stack = []
        for j in range(m):
            while stack and grid[i][stack[-1]] < grid[i][j]:
                stack.pop()
            if not stack:
                left[i][j] = j  # can see all the way left
            else:
                left[i][j] = j - stack[-1] - 1
            stack.append(j)

    # RIGHT
    for i in range(n):
        stack = []
        for j in range(m-1, -1, -1):
            while stack and grid[i][stack[-1]] < grid[i][j]:
                stack.pop()
            if not stack:
                right[i][j] = m - 1 - j
            else:
                right[i][j] = stack[-1] - j - 1
            stack.append(j)

    # UP
    for j in range(m):
        stack = []
        for i in range(n):
            while stack and grid[stack[-1]][j] < grid[i][j]:
                stack.pop()
            if not stack:
                up[i][j] = i
            else:
                up[i][j] = i - stack[-1] - 1
            stack.append(i)

    # DOWN
    for j in range(m):
        stack = []
        for i in range(n-1, -1, -1):
            while stack and grid[stack[-1]][j] < grid[i][j]:
                stack.pop()
            if not stack:
                down[i][j] = n - 1 - i
            else:
                down[i][j] = stack[-1] - i - 1
            stack.append(i)

    # Compute coverage
    max_cover = 0
    for i in range(n):
        for j in range(m):
            cover = 1 + left[i][j] + right[i][j] + up[i][j] + down[i][j]
            max_cover = max(max_cover, cover)

    return max_cover


# -------------------------
# MAIN (handles custom input)
# -------------------------
if __name__ == "__main__":
    N, M = map(int, input().split())
    grid = [list(map(int, input().split())) for _ in range(N)]
    print(max_coverage(grid))




class DSU:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        xr, yr = self.find(x), self.find(y)
        if xr == yr:
            return False
        if self.rank[xr] < self.rank[yr]:
            self.parent[xr] = yr
        elif self.rank[xr] > self.rank[yr]:
            self.parent[yr] = xr
        else:
            self.parent[yr] = xr
            self.rank[xr] += 1
        return True


n, m, k, f = map(int, input().split())
edges = []
for _ in range(m):
    u, v, w = map(int, input().split())
    edges.append((w, min(u, v), max(u, v)))

mandatory = set()
for _ in range(k):
    u, v = map(int, input().split())
    mandatory.add((min(u, v), max(u, v)))

forbidden = set()
for _ in range(f):
    u, v = map(int, input().split())
    forbidden.add((min(u, v), max(u, v)))

# Sort edges by (weight, u, v) — ensures lexicographic priority
edges.sort(key=lambda x: (x[0], x[1], x[2]))

dsu = DSU(n)
mst = []
cost = 0

# Step 1: Add mandatory edges first
for w, u, v in edges:
    if (u, v) in forbidden:
        continue
    if (u, v) in mandatory:
        if not dsu.union(u, v):  # cycle with mandatory edge → impossible
            print(-1)
            exit()
        mst.append((u, v, w))
        cost += w

# Step 2: Add remaining edges in strict lexicographic order
for w, u, v in edges:
    if (u, v) in forbidden or (u, v) in mandatory:
        continue
    if dsu.union(u, v):
        mst.append((u, v, w))
        cost += w
    if len(mst) == n - 1:
        break

# Step 3: Validate MST
if len(mst) != n - 1 or not all(dsu.find(0) == dsu.find(i) for i in range(n)):
    print(-1)
else:
    # Sort final MST edges lexicographically
    mst_sorted = sorted((u, v) for u, v, _ in mst)
    print(cost)
    for u, v in mst_sorted:
        print(u, v)